# Simulateur RÃ©seau LoRa (Python 3.10+)

Bienvenue ! Ce projet est un **simulateur complet de rÃ©seau LoRa**, inspirÃ© du fonctionnement de FLoRa sous OMNeT++, codÃ© entiÃ¨rement en Python.

## ğŸ› ï¸ Installation

1. **Clonez ou tÃ©lÃ©chargez** le projet.
2. **CrÃ©ez un environnement virtuel et installez les dÃ©pendancesÂ :**
   ```bash
   python3 -m venv env
   source env/bin/activate  # Sous Windows : env\Scripts\activate
   pip install -r requirements.txt
   ```
3. **Lancez le tableau de bordÂ :**
   ```bash
   panel serve dashboard.py --show
   ```
4. **ExÃ©cutez des simulations en ligne de commandeÂ :**
   ```bash
   python run.py --nodes 30 --gateways 1 --area 1000 --mode Random --interval 10 --steps 100 --output resultats.csv
   python run.py --nodes 20 --mode Random --interval 15
   python run.py --nodes 5 --mode Periodic --interval 10
   ```

## Duty cycle

Le simulateur applique par dÃ©faut un duty cycle de 1Â % pour se rapprocher des
contraintes LoRa rÃ©elles. Le gestionnaire de duty cycle situÃ© dans
`duty_cycle.py` peut Ãªtre configurÃ© en passant un autre paramÃ¨tre `duty_cycle`
Ã  `Simulator` (par exemple `0.02` pour 2Â %). Transmettre `None` dÃ©sactive ce
mÃ©canisme. Les transmissions sont automatiquement retardÃ©es pour respecter ce
pourcentage.

## MobilitÃ© optionnelle

La mobilitÃ© des nÅ“uds peut dÃ©sormais Ãªtre activÃ©e ou dÃ©sactivÃ©e lors de la
crÃ©ation du `Simulator` grÃ¢ce au paramÃ¨tre `mobility` (boolÃ©en). Dans le
`dashboard`, cette option correspond Ã  la case Â«Â Activer la mobilitÃ© des
nÅ“udsÂ Â». Si elle est dÃ©cochÃ©e, les positions des nÅ“uds restent fixes pendant
la simulation.
Lorsque la mobilitÃ© est active, les dÃ©placements sont progressifs et suivent
des trajectoires lissÃ©es par interpolation de BÃ©zier. La vitesse des nÅ“uds est
tirÃ©e alÃ©atoirement dans la plage spÃ©cifiÃ©e (par dÃ©faut 2 Ã  10Â m/s) et peut Ãªtre
modifiÃ©e via le paramÃ¨tre `mobility_speed` du `Simulator`. Les mouvements sont
donc continus et sans tÃ©lÃ©portation.
Deux champs Â«â€¯Vitesse minâ€¯Â» et Â«â€¯Vitesse maxâ€¯Â» sont disponibles dans le
`dashboard` pour dÃ©finir cette plage avant de lancer la simulation.

## Multi-canaux

Le simulateur permet d'utiliser plusieurs canaux radio. Passez une instance
`MultiChannel` ou une liste de frÃ©quences Ã  `Simulator` via les paramÃ¨tres
`channels` et `channel_distribution`. Dans le `dashboard`, rÃ©glez **Nb
sous-canaux** et **RÃ©partition canaux** pour tester un partage Roundâ€‘robin ou
alÃ©atoire des frÃ©quences entre les nÅ“uds.

## ParamÃ¨tres radio avancÃ©s

Le constructeur `Channel` accepte trois options pour modÃ©liser plus finement la
rÃ©ceptionÂ :

- `cable_loss`Â : pertes fixes (dB) entre le transceiver et l'antenne.
- `receiver_noise_floor`Â : bruit thermique de rÃ©fÃ©rence en dBm/Hz (par dÃ©faut
  `-174`).
- `noise_figure`Â : facteur de bruit du rÃ©cepteur en dB.

Ces valeurs influencent le calcul du RSSI et du SNR retournÃ©s par
`Channel.compute_rssi`.

## SF et puissance initiaux

Deux nouvelles cases Ã  cocher du tableau de bord permettent de fixer le
Spreading Factor et/ou la puissance d'Ã©mission de tous les nÅ“uds avant le
lancement de la simulation. Une fois la case cochÃ©e, sÃ©lectionnez la valeur
souhaitÃ©e via le curseur associÃ© (SFÂ 7â€‘12 et puissance 2â€‘14Â dBm). Si la case est
dÃ©cochÃ©e, chaque nÅ“ud conserve des valeurs alÃ©atoires par dÃ©faut.

## FonctionnalitÃ©s LoRaWAN

Une couche LoRaWAN simplifiÃ©e est maintenant disponible. Le module
`lorawan.py` dÃ©finit la structure `LoRaWANFrame` ainsi que les fenÃªtres
`RX1` et `RX2`. Les nÅ“uds possÃ¨dent des compteurs de trames et les passerelles
peuvent mettre en file d'attente des downlinks via `NetworkServer.send_downlink`.

Depuis cette version, les commandes `LinkADRReq`/`LinkADRAns` sont gÃ©rÃ©es afin
d'ajuster le Spreading Factor et la puissance d'Ã©mission selon la spÃ©cification
LoRaWAN. Le serveur encode la requÃªte et le nÅ“ud y rÃ©pond automatiquement lors
du prochain uplink.

Lancer l'exemple minimalÂ :

```bash
python run.py --lorawan-demo
```
 
